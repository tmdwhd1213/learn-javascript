<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <button id="btn1">Click me!</button>
    <script>
      // 이벤트가 발생했을 때 호출될 함수를 이벤트 핸들러라고 함.
      // 브라우저에게 이벤트 핸들러의 호출을 위임하는 것을 이벤트 핸들러 등록이라 함.
      // 클릭 이벤트가 발생하면 특정 함수(이벤트 핸들러)를 호출하도록 브라우저에게 위임할 수 있다.
      // 즉 함수를 언제 호출할지 알 수 없으므로 브라우저에게 호출을 위임하는 것이다.
      const $button = document.getElementById("btn1");
      // 사용자가 버튼을 클릭하면 함수를 호출하도록 요청
      $button.onclick = function () {
        alert("button click");
      };

      // 이와 같이 프로그램의 흐름을 이벤트 중심으로 제어하는 프로그래밍 방식을 이벤트 드리븐
      // 프로그래밍이라고 한다.

      // click: 마우스를 클릭
      // dblClick: 마우스 더블 클릭
      // mousedown: 마우스 버튼 눌렀을 때
      // mouseup: 누르고 있던 마우스 버튼을 놓았을 때
      // mousemove: 마우스 커서를 움직였을 때
      // mouseenter: 마우스 커서를 HTML 요소 안으로 이동했을 때(버블링되지 않음)
      // mouseover: 위와 같음(버블링 됨)
      // mouseleave: 마우스 커서를 HTML 요소 밖으로 이동했을 때(버블링 X)
      // mouseout: 위와 같음 (버블링 됨)

      // keydown: 모든 키를 눌렀을 때 발생
      // keypress: 문자 키를 눌렀을 때 연속적으로 발생
      // keyup: 누르고 있던 키를 놓았을 때 한번만 발생

      // focus: HTML 요소가 포커스를 받았을 때 (버블링 X)
      // blur: HTML 요소가 포커스를 잃었을 때 (버블링 X)
      // focusin: 포커스 받을 때 (버블링 O)
      // focusout: 포커스 잃을 때 (버블링 O)

      // submit: form 요소 내의 submit 버튼을 클릭했을 때
      // reset: form 요소 내의 reset 버튼을 클릭했을 때 (최근에는 사용 X)

      // input: input(text, radio, checkbox), select, textarea 요소의 값이 입력될 때
      // change: 위의 값이 변경될 때 (포커스를 잃을 때 사용자의 입력이 종료됐다 판단, 발생)
      // readystatechange: HTML 문서의 로드와 파싱 상태를 나타내는 readyState 프로퍼티 값
      // ('loading', 'interactive', 'complete')이 변경될 때

      // DOM 뮤테이션 이벤트
      // DOMContentLoaded: HTML 문서의 로드와 파싱이 완료되어 DOM 생성이 완료되었을 떄

      // 뷰 이벤트
      // resize: 브라우저 윈도우의 크기를 리사이즈할 때 연속적으로 발생
      // scroll: 웹페이지 or HTML 요소를 스크롤할 때 연속적으로 발생

      // 리소스 이벤트
      // load: DOMContentLoaded 이벤트가 발생 후, 모든 리소스(이미지, 폰트 등)의 로딩이 완료
      // unload: 리소스가 언로드될 때 (주로 새로운 웹페이지를 요청한 경우)
      // abort: 리소스 로딩이 중단되었을 때
      // error: 리소스 로딩이 실패했을 때

      // 이벤트 핸들러 등록
      // 이벤트 핸들러 어트리뷰트 방식
      // <button onClick="sayHi('Lee')">Click me!</button>
      // 처럼 함수 참조가 아닌, 함수 호출문등의 문을 할당한다.
      // 이때 이벤트 핸들러 어트리뷰트 값은 사실 암묵적으로 생성될 이벤트 핸들러의
      // 함수 몸체를 의미한다.
      /*
        function onclick(event) {
          sayHi('Lee');
        }
      */
      // 이처럼 동작하는 이유는 이벤트 핸들러에 인수를 전달하기 위함이다.

      // $button.onclick이나 어트리뷰트 방식은 하나의 이벤트에 하나의 핸들만 바인딩할 수 있다.
      // 한번 더 이벤트를 바인딩시키면 첫번째 이벤트는 덮어진다.

      // EventTarget.prototype.addEventListener 메서드를 사용하여 여러 개의 이벤트 핸들러를
      // 등록할 수 있다.
      // EventTarget.addEventListener('eventType', functionName, [, useCapture])
      $button.addEventListener("click", function () {
        console.log("[이벤트 핸들러 프로퍼티 방식]button click");
      });
      // 참조가 동일한 이벤트 핸들러를 중복 등록하면 하나의 핸들러만 등록된다.
      const handleClick = () => console.log("test");
      $button.addEventListener("click", handleClick);
      $button.addEventListener("click", handleClick);
      // 이벤트 핸들러 제거
      // addEventListener로 등록한 이벤트 핸들러를 제거하려면 removeEventLister 메서드 사용
      // 동일한 인수를 전달해야 함. 일치하지 않으면 무시됨.
      // 무명함수를 이벤트 핸들러로 등록한 경우 제거할 수 없다.
      // 기명함수 내부에서 removeEventListener로 제거하는 것은 가능하다.
      // 단 한 번만 호출된다. 여러 번 클릭해도 단 한번만 이벤트 핸들러가 호출된다
      $button.addEventListener("click", function foo() {
        console.log("foo");
        // 이벤트 핸들러 제거
        $button.removeEventListener("click", foo);
      });

      // 이벤트 핸들러 프로퍼티 방식으로 등록한 핸들러는 removeEventListener로 제거 X.
      // EventTarget.onclick = null을 할당하여 이벤트 핸들러로 제거한다.
    </script>
  </body>
</html>
