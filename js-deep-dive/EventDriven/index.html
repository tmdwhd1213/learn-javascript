<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>김이랑 사랑해</title>
    <style>
      .box {
        width: 100px;
        height: 100px;
        background-color: #fff700;
        border: 5px solid orange;
        cursor: pointer;
      }
    </style>
  </head>
  <!-- 이벤트 어트리뷰트로는 무조건 event를 인수로 받아야 함. -->
  <body onclick="showCoords(event)">
    <button id="btn1">Click me!</button>
    <p>클릭하세요. 클릭한 곳의 좌표가 표시됩니다.</p>
    <em class="message">off</em>

    <input type="text" />
    <input type="checkbox" />
    <button>나 클릭</button>
    <div class="box"></div>
    <div>
      <em class="msg" style="font-size: 100px; color: palevioletred"></em>
    </div>
    <script>
      // 이벤트가 발생했을 때 호출될 함수를 이벤트 핸들러라고 함.
      // 브라우저에게 이벤트 핸들러의 호출을 위임하는 것을 이벤트 핸들러 등록이라 함.
      // 클릭 이벤트가 발생하면 특정 함수(이벤트 핸들러)를 호출하도록 브라우저에게 위임할 수 있다.
      // 즉 함수를 언제 호출할지 알 수 없으므로 브라우저에게 호출을 위임하는 것이다.
      const $button = document.getElementById("btn1");
      // 사용자가 버튼을 클릭하면 함수를 호출하도록 요청
      $button.onclick = function () {
        alert("button click");
      };

      // 이와 같이 프로그램의 흐름을 이벤트 중심으로 제어하는 프로그래밍 방식을 이벤트 드리븐
      // 프로그래밍이라고 한다.

      // click: 마우스를 클릭
      // dblClick: 마우스 더블 클릭
      // mousedown: 마우스 버튼 눌렀을 때
      // mouseup: 누르고 있던 마우스 버튼을 놓았을 때
      // mousemove: 마우스 커서를 움직였을 때
      // mouseenter: 마우스 커서를 HTML 요소 안으로 이동했을 때(버블링되지 않음)
      // mouseover: 위와 같음(버블링 됨)
      // mouseleave: 마우스 커서를 HTML 요소 밖으로 이동했을 때(버블링 X)
      // mouseout: 위와 같음 (버블링 됨)

      // keydown: 모든 키를 눌렀을 때 발생
      // keypress: 문자 키를 눌렀을 때 연속적으로 발생
      // keyup: 누르고 있던 키를 놓았을 때 한번만 발생

      // focus: HTML 요소가 포커스를 받았을 때 (버블링 X)
      // blur: HTML 요소가 포커스를 잃었을 때 (버블링 X)
      // focusin: 포커스 받을 때 (버블링 O)
      // focusout: 포커스 잃을 때 (버블링 O)

      // submit: form 요소 내의 submit 버튼을 클릭했을 때
      // reset: form 요소 내의 reset 버튼을 클릭했을 때 (최근에는 사용 X)

      // input: input(text, radio, checkbox), select, textarea 요소의 값이 입력될 때
      // change: 위의 값이 변경될 때 (포커스를 잃을 때 사용자의 입력이 종료됐다 판단, 발생)
      // readystatechange: HTML 문서의 로드와 파싱 상태를 나타내는 readyState 프로퍼티 값
      // ('loading', 'interactive', 'complete')이 변경될 때

      // DOM 뮤테이션 이벤트
      // DOMContentLoaded: HTML 문서의 로드와 파싱이 완료되어 DOM 생성이 완료되었을 떄

      // 뷰 이벤트
      // resize: 브라우저 윈도우의 크기를 리사이즈할 때 연속적으로 발생
      // scroll: 웹페이지 or HTML 요소를 스크롤할 때 연속적으로 발생

      // 리소스 이벤트
      // load: DOMContentLoaded 이벤트가 발생 후, 모든 리소스(이미지, 폰트 등)의 로딩이 완료
      // unload: 리소스가 언로드될 때 (주로 새로운 웹페이지를 요청한 경우)
      // abort: 리소스 로딩이 중단되었을 때
      // error: 리소스 로딩이 실패했을 때

      // 이벤트 핸들러 등록
      // 이벤트 핸들러 어트리뷰트 방식
      // <button onClick="sayHi('Lee')">Click me!</button>
      // 처럼 함수 참조가 아닌, 함수 호출문등의 문을 할당한다.
      // 이때 이벤트 핸들러 어트리뷰트 값은 사실 암묵적으로 생성될 이벤트 핸들러의
      // 함수 몸체를 의미한다.
      /*
        function onclick(event) {
          sayHi('Lee');
        }
      */
      // 이처럼 동작하는 이유는 이벤트 핸들러에 인수를 전달하기 위함이다.

      // $button.onclick이나 어트리뷰트 방식은 하나의 이벤트에 하나의 핸들만 바인딩할 수 있다.
      // 한번 더 이벤트를 바인딩시키면 첫번째 이벤트는 덮어진다.

      // EventTarget.prototype.addEventListener 메서드를 사용하여 여러 개의 이벤트 핸들러를
      // 등록할 수 있다.
      // EventTarget.addEventListener('eventType', functionName, [, useCapture])
      $button.addEventListener("click", function () {
        console.log("[이벤트 핸들러 프로퍼티 방식]button click");
      });
      // 참조가 동일한 이벤트 핸들러를 중복 등록하면 하나의 핸들러만 등록된다.
      const handleClick = () => console.log("test");
      $button.addEventListener("click", handleClick);
      $button.addEventListener("click", handleClick);
      // 이벤트 핸들러 제거
      // addEventListener로 등록한 이벤트 핸들러를 제거하려면 removeEventLister 메서드 사용
      // 동일한 인수를 전달해야 함. 일치하지 않으면 무시됨.
      // 무명함수를 이벤트 핸들러로 등록한 경우 제거할 수 없다.
      // 기명함수 내부에서 removeEventListener로 제거하는 것은 가능하다.
      // 단 한 번만 호출된다. 여러 번 클릭해도 단 한번만 이벤트 핸들러가 호출된다
      $button.addEventListener("click", function foo() {
        console.log("foo");
        // 이벤트 핸들러 제거
        $button.removeEventListener("click", foo);
      });

      // 이벤트 핸들러 프로퍼티 방식으로 등록한 핸들러는 removeEventListener로 제거 X.
      // EventTarget.onclick = null을 할당하여 이벤트 핸들러로 제거한다.
      // 이벤트 객체
      // 이벤트가 발생하면 이벤트에 관한 정보를 담고있는 객체가 동적으로 생성된다.
      // 생성된 이벤트 객체는 이벤트 핸들러의 첫 번째 인수로 전달된다.
      const $msg = document.querySelector(".message");
      // 클릭 이벤트에 의해 생성된 이벤트 객체는 이벤트 핸들러의 첫 번째 인수로 전달됨.
      function showCoords(e) {
        $msg.textContent = `clientX: ${e.clientX}, clientY: ${e.clientY}`;
      }
      document.addEventListener("click", showCoords);

      // Event 생성자 함수를 호출하여 foo 이벤트 타입의 Event 객체를 생성
      let e = new Event("foo");
      console.log(e);
      // Event {isTrusted: false, type: 'foo', target: null, currentTarget: null, eventPhase: 0, …}
      console.log(e.type); // "foo"
      console.log(e instanceof Event);
      console.log(e instanceof Object);
      // FocusEvent
      e = new FocusEvent("focus");
      console.log(e);
      // FocusEvent {isTrusted: false, relatedTarget: null, view: null, detail: 0, sourceCapabilities: null, …}
      e = new MouseEvent("click");
      console.log(e);

      e = new KeyboardEvent("keyup");
      console.log(e);

      e = new InputEvent("change");
      console.log(e);

      const $input = document.querySelector("input[type=text]");
      const $checkbox = document.querySelector("input[type=checkbox]");
      const $button1 = document.querySelector("button");

      // load 이벤트가 발생하면 Event 타입의 이벤트 객체가 생성된다.
      window.onload = console.log;
      // change가 발생하면
      $checkbox.onchange = console.log;
      // focus
      $input.onfocus = console.log;
      $input.oninput = console.log;
      $input.onkeyup = console.log;
      $button1.onclick = console.log;
      // currentTarget -> 이벤트 핸들러가 바인딩된 DOM 요소
      // eventPhase -> 이벤트 전파 단계
      // 0: 이벤트 없음, 1: 캡처링 단계, 2: 타깃 단계 3: 버블링 단계
      // bubbles -> 이벤트를 버블링으로 전파하는지 여부

      // change 이벤트가 발생하면 Event 타입의 이벤트 객체가 생성된다.
      $checkbox.onchange = (e) => {
        console.log(Object.getPrototypeOf(e) === Event.prototype); // true

        // e.target은 change 이벤트를 발생시킨 DOM 요소 $checkbox를 가리키고
        // e.target.checked는 체크박스 요소의 현재 체크 상태를 나타낸다.
        $msg.textContent = e.target.checked ? "on" : "off";
      };

      const $box = document.querySelector(".box");

      // 드래그 시작 시점의 마우스 포인터 위치
      const initialMousePos = { x: 0, y: 0 };
      // 오프셋: 이동할 거리
      const offset = { x: 0, y: 0 };

      // mousemove 이벤트 핸들러
      const move = (e) => {
        // 오프셋 = 현재(드래그하고 있는 시점) 포인터 좌표 - 시작 지점 좌표
        offset.x = e.clientX - initialMousePos.x;
        offset.y = e.clientY - initialMousePos.y;

        // translate3d는 GPU를 사용하므로 absolute의 top, left를 사용하는 것보다 빠르다.
        // top, left는 레이아웃에 영향을 준다.
        $box.style.transform = `translate3d(${offset.x}px, ${offset.y}px, 0)`;
      };

      // mousedown 이벤트가 발생하면 드래그 시작 시점의 마우스 포인터 좌표를 저장
      $box.addEventListener("mousedown", (e) => {
        initialMousePos.x = e.clientX - offset.x;
        initialMousePos.y = e.clientY - offset.y;

        // mousedown 이벤트가 발생한 상태에서 mouseMove 이벤트가 발생하면 box 요소를 이동시킴.
        document.addEventListener("mousemove", move);
      });

      // mouseup 이벤트가 발생하면 제거함.
      document.addEventListener("mouseup", () => {
        document.removeEventListener("mousemove", move);
      });

      // 키보드 정보 취득
      const $message = document.querySelector(".msg");
      $input.onkeyup = (e) => {
        // e.key는 입력한 키 값을 문자열로 반환한다.
        // 입력한 키가 'Enter' 즉 엔터 키가 아니면 무시한다.
        if (e.key !== "Enter") return;

        // 엔터키가 입력되면 현재까지 입력 필드에 입력된 값을 출력한다
        $message.textContent = e.target.value;
        e.target.value = "";
      };
    </script>
  </body>
</html>
